# -*- coding: utf-8 -*-
"""006main_esp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mPmzgLYTZGR3xkZpcghtxtbF5S10P7JY
"""

import numpy as np

# Imprimir la versión y la configuración de numpy
print("Versión de NumPy:", np.__version__)
print("\nConfiguración de NumPy:")
print(np.show_config())

# Generar un array tridimensional de 2x3x5 con valores aleatorios
a = np.random.rand(2, 3, 5)
print("\nArray a:")
print(a)

# Crear un array tridimensional de 5x2x3 con todos los valores igual a 1
b = np.ones((5, 2, 3))
print("\nArray b:")
print(b)

# Verificar si a y b tienen el mismo tamaño
print("\n¿a y b tienen el mismo tamaño?:", a.size == b.size)

# Intentar sumar a y b (no será posible porque tienen formas diferentes)
# Esto arrojará un error de ValueError: operands could not be broadcast together with shapes...
# c = a + b

# Transponer b para que tenga la misma forma que a
c = np.transpose(b, (1, 2, 0))
print("\nArray c (transpuesto de b):")
print(c)

# Sumar a y c
d = a + c
print("\nArray d (suma de a y c):")
print(d)

# Imprimir a y d
print("\nArray a:")
print(a)
print("\nArray d:")
print(d)

# Multiplicar a y c
e = a * c
print("\nArray e (producto de a y c):")
print(e)

# Comprobar si e es igual a a (debería serlo porque todos los elementos de c son 1)
print("\n¿e es igual a a?:", np.array_equal(e, a))

# Identificar los valores máximos, mínimos y medios en d
d_max = np.max(d)
d_min = np.min(d)
d_mean = np.mean(d)
print("\nValor máximo en d:", d_max)
print("Valor mínimo en d:", d_min)
print("Valor medio en d:", d_mean)

# Crear un array vacío f con la misma forma que d
f = np.empty_like(d)

# Rellenar los valores en f según las condiciones especificadas
f[(d > d_min) & (d < d_mean)] = 25
f[(d > d_mean) & (d < d_max)] = 75
f[d == d_mean] = 50
f[d == d_min] = 0
f[d == d_max] = 100

# Imprimir d y f
print("\nArray d:")
print(d)
print("\nArray f:")
print(f)

# Pregunta de bonificación: etiquetar los elementos del array con cadenas en lugar de números
etiquetas = np.array(['A', 'B', 'C', 'D', 'E'])
g = np.empty_like(d, dtype=str)
g[(d > d_min) & (d < d_mean)] = 'B'
g[(d > d_mean) & (d < d_max)] = 'D'
g[d == d_mean] = 'C'
g[d == d_min] = 'A'
g[d == d_max] = 'E'

# Imprimir g
print("\nArray g (etiquetado con cadenas):")
print(g)